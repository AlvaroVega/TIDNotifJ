/*
* MORFEO Project
* http://www.morfeo-project.org
*
* Component: TIDNotifJ
* Programming Language: Java
*
* File: $Source$
* Version: $Revision: 3 $
* Date: $Date: 2006-01-17 17:42:13 +0100 (Tue, 17 Jan 2006) $
* Last modified by: $Author: aarranz $
*
* (C) Copyright 2005 Telefónica Investigación y Desarrollo
*     S.A.Unipersonal (Telefónica I+D)
*
* Info about members and contributors of the MORFEO project
* is available at:
*
*   http://www.morfeo-project.org/TIDNotifJ/CREDITS
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*
* If you want to use this software an plan to distribute a
* proprietary application in any way, and you are not licensing and
* distributing your source code under GPL, you probably need to
* purchase a commercial license of the product.  More info about
* licensing options is available at:
*
*   http://www.morfeo-project.org/TIDNotifJ/Licensing
*/ 

/* Generated By:JJTree: Do not edit this line. TIDRelationalExpr.java */

package es.tid.util.parser;

import es.tid.util.parser.Operations.TIDRelationalOperations;

public class TIDRelationalExpr extends SimpleNode implements TIDRelationalOperations, TIDConstraintMsg
{
  private static final String NODENAME = "RelationalExpr: ";

  private static final char WILDCHAR = '%';
  private static final char JOKER = '_';

  private String name;
  private int operator;

  public TIDRelationalExpr(int id) {
    super(id);
    super.node_type = NodeType.TIDRelationalExpr;
  }

  public TIDRelationalExpr(ConstraintParser p, int id) {
    super(p, id);
    super.node_type = NodeType.TIDRelationalExpr;
  }

  public void setOp(int op) 
  {
    try
    {
      operator = op;
      name = STR_OP[op-FIRST_OP];
    }
    catch (Exception e)
    {
      operator = UNKNOWN_OP;
      name = STR_OP[UNKNOWN_OP-FIRST_OP];
    }
  }

  public int getOp()
  {
    return this.operator;
  }

  public String toString() {
    return NODENAME + name;
  }

  public TypeValuePair evaluate( org.omg.DynamicAny.DynAny dynany )
  {
    if (children != null) 
    {
      int j = 0;
      TypeValuePair operand[] = new TypeValuePair[2];

      for (int i = 0; i < children.length; ++i) 
      {
        SimpleNode n = (SimpleNode)children[i];

        if (n != null) 
        {
          operand[j++] = n.evaluate( dynany );
        }
      }

      if (j == 2) // Todo OK
      {
        TypeValuePair result = performOperation(operand[0], operand[1]);
        operand[0] = null;
        operand[1] = null;
        return result;
      }
      else // Num. hijos incorrecto
      {
        TIDParser.print(TIDParser.ERROR, TRE_NUM_HIJOS);
      }
    }
    else
    {
      TIDParser.print(TIDParser.ERROR, TRE_NO_HIJOS);
    }
    return new TypeValuePair(); // Ahora vale ERRTYPE
  }


  private boolean performNumericOp( int op, float d1, float d2)
  {
    switch (op)
    {
      case EQ_OP: 
        return (d1 == d2);
      case DIFF_OP:
      case DIFF2_OP: 
        return (d1 != d2);
      case LESS_OP: 
        return (d1 < d2);
      case LESSEQ_OP: 
        return (d1<= d2);
      case GREAT_OP: 
        return (d1 > d2);
      case GREATEQ_OP: 
        return (d1 >= d2);
    }
    return false;
  }

  private boolean performStringOp(int op, String s1, String s2)
  {
    switch (op)
    {
      case EQ_OP:
        return (s1.compareTo(s2) == 0);
      case DIFF_OP:
      case DIFF2_OP:
        return (s1.compareTo(s2) != 0);
      case LESS_OP:
        return (s1.compareTo(s2) < 0);
      case LESSEQ_OP:
        return (s1.compareTo(s2) <= 0);
      case GREAT_OP:
        return (s1.compareTo(s2) > 0);
      case GREATEQ_OP:
        return (s1.compareTo(s2) >= 0);
      case LIKE_OP:
        return like(s1, s2);
    }
    return false;
  }

  private boolean performBoolOp( int op, boolean d1, boolean d2)
  {
    switch (op)
    {
      case EQ_OP:
        return (d1 == d2);
      case DIFF_OP:
      case DIFF2_OP:
        return (d1 != d2);
    }
    return false;
  }

  private TypeValuePair performOperation( TypeValuePair operand1,
                                          TypeValuePair operand2)
  {
    switch (operand1.type)
    {
      case TypeValuePair.BOOLTYPE:
        {
        if (operand2.type == TypeValuePair.BOOLTYPE)
        {
          return new TypeValuePair( performBoolOp(operator,
                             ((Boolean)operand1.val.objVal).booleanValue(),
                             ((Boolean)operand2.val.objVal).booleanValue() ) );
        }
        return new TypeValuePair();
        }
      case TypeValuePair.ITYPE:
        {
        if ( operand2.type == TypeValuePair.ITYPE )
        {
          return new TypeValuePair( performNumericOp(operator,
                                 ((Integer)operand1.val.objVal).intValue(),
                                 ((Integer)operand2.val.objVal).intValue() ) );
        }
        else if ( operand2.type == TypeValuePair.FTYPE )
        {
          return new TypeValuePair( performNumericOp(operator,
                                 ((Integer)operand1.val.objVal).floatValue(),
                                 ((Float)operand2.val.objVal).floatValue() ) );
        }
        else if ( operand2.type == TypeValuePair.ENUMTYPE &&
                  ((EnumValue)operand2.val.objVal).numValue() != -1 )
        {
          return new TypeValuePair( performNumericOp(operator,
                               ((Integer)operand1.val.objVal).intValue(),
                               ((EnumValue)operand2.val.objVal).numValue() ) );
        }
        return new TypeValuePair();
        }
     case TypeValuePair.FTYPE:
        {
        if ( operand2.type == TypeValuePair.ITYPE )
        {
          return new TypeValuePair( performNumericOp(operator,
                               ((Float)operand1.val.objVal).floatValue(),
                               ((Integer)operand2.val.objVal).floatValue() ) );
        }
        else if ( operand2.type == TypeValuePair.FTYPE )
        {
          return new TypeValuePair( performNumericOp(operator,
                                 ((Float)operand1.val.objVal).floatValue(),
                                 ((Float)operand2.val.objVal).floatValue() ) );
        }
        else if (operand2.type == TypeValuePair.ENUMTYPE &&
              ((EnumValue)operand2.val.objVal).numValue() != -1)
        {
          return new TypeValuePair( performNumericOp(operator,
                        ((Float)operand1.val.objVal).floatValue(),
                        (float)((EnumValue)operand2.val.objVal).numValue() ) );
        }
        return new TypeValuePair();
        }
     case TypeValuePair.STRTYPE:
        {
        if (operand2.type == TypeValuePair.STRTYPE)
        {
          return new TypeValuePair(
                  performStringOp( operator, (String)operand1.val.objVal,
                                               (String)operand2.val.objVal ) );
        }
        else if (operand2.type == TypeValuePair.ENUMTYPE &&
              ((EnumValue)operand2.val.objVal).numValue() != -1)
        {
          int val_operand1 = ((EnumValue)operand2.val.objVal).stringValues(
                                                  (String)operand1.val.objVal);
          if (val_operand1 != -1)
          {
            return new TypeValuePair(performNumericOp( operator, val_operand1,
                               ((EnumValue)operand2.val.objVal).numValue() ) );
          }
        }
        return new TypeValuePair();
        }
     case TypeValuePair.ENUMTYPE:
        {
        if (operand2.type == TypeValuePair.ENUMTYPE)
        {
          if ( (((EnumValue)operand1.val.objVal).numValue() == -1) ||
               (((EnumValue)operand2.val.objVal).numValue() == -1) )
          {
            return new TypeValuePair( performStringOp(operator,
                            ((EnumValue)operand1.val.objVal).stringValue(),
                            ((EnumValue)operand2.val.objVal).stringValue() ) );
          }
          return new TypeValuePair( performNumericOp(operator,
                        (float)((EnumValue)operand1.val.objVal).numValue(),
                        (float)((EnumValue)operand2.val.objVal).numValue() ) );
        }
        else if ( (operand2.type == TypeValuePair.ITYPE ||
                   operand2.type == TypeValuePair.FTYPE ) &&
                  (((EnumValue)operand1.val.objVal).numValue() != -1) )
        {
          return new TypeValuePair( performNumericOp(operator,
                         (float)((EnumValue)operand1.val.objVal).numValue(),
                         ((Integer)operand2.val.objVal).floatValue()) );
        }
        else if (operand2.type == TypeValuePair.STRTYPE)
        {
          int val_operand2 = ((EnumValue)operand1.val.objVal).stringValues(
                                                  (String)operand2.val.objVal);
          if (val_operand2 != -1)
          {
            return new TypeValuePair( performNumericOp( operator, 
                 ((EnumValue)operand1.val.objVal).numValue(), val_operand2 ) );
          }
        }
        return new TypeValuePair();
        }
     default:
       TRE_OPERAND_ERROR[1] = Integer.toString(operand1.type);
       TIDParser.print(TIDParser.DEBUG, TRE_OPERAND_ERROR);
     }
     return new TypeValuePair();
  }

  static boolean like(String str_value, String str_mask)
  {
    char[] value = str_value.toCharArray();
    char[] mask = str_mask.toCharArray();

    if ((mask.length == 0) && (value.length > 0)) return false;
    if ((mask.length == 1)&&(mask[0]==JOKER)&&(value.length > 1)) return false;

    int index = 0;
    while ( (index < value.length) && 
            (index < mask.length) && 
            (mask[index] != WILDCHAR) )
    {
      if ((mask[index] != value[index]) && (mask[index] != JOKER))
      {
        return false;
      }
      index++;
    }

    int index2 = index;
    int cp = 0;
    int mp = 0;

    //System.out.println("1)i="+index+",i2="+index2+",mp="+mp+",cp="+cp);

    // Con esta linea es como si siempre terminara en %
    while ((index2 < value.length) && (index2 < mask.length))
    //
    // Con esta linea se fuerza a poner %, en caso contrario actua como un "="
    //
    //while (index2 < value.length)
    {
      if (!(index < mask.length) && (index2 < value.length))
      {
        //System.out.print("2)");
        index = mp;
        index2 = cp++;
        //System.out.println("i="+index+",i2="+index2+",mp="+mp+",cp="+cp);
      }
      if (mask[index] == WILDCHAR)
      {
        //System.out.print("3)");
        index++;
        if (!(index < mask.length))
        {
          //System.out.println("true");
          return true;
        }
        mp = index;
        cp = index2+1;
        //System.out.println("i="+index+",i2="+index2+",mp="+mp+",cp="+cp);
      }
      else if ((mask[index] == value[index2]) || (mask[index] == JOKER))
      {
        //System.out.print("4)");
        index++;
        index2++;
        //System.out.println("i="+index+",i2="+index2+",mp="+mp+",cp="+cp);
      }
      else
      {
        //System.out.print("5)");
        index = mp;
        index2 = cp++;
        //System.out.println("i="+index+",i2="+index2+",mp="+mp+",cp="+cp);
      }
    }

    while ((index < mask.length) && (mask[index] == WILDCHAR))
    {
      //System.out.print("6)");
      index++;
      //System.out.println("i="+index+",i2="+index2+",mp="+mp+",cp="+cp);
    }

    return !(index<mask.length);
  }
}
